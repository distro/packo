#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'nokogiri'
require 'digest/sha1'

require 'packo'
require 'packo/binary'
require 'packo/rbuild'

class Application < Optitron::CLI
  include Packo
  include Binary::Helpers
  include Models

  desc 'Output version'
  def version
    puts "packÃ¸ building tool #{VERSION}"
  end

  desc 'Creates a package'
  opt 'output', 'The directory where to save packages', :default => Environment[:TMP]
  opt 'wipe', 'Wipes the package directory before building it', :type => :boolean, :default => false, :short_name => 'w'
  opt 'repository', 'Set a specific source repository', :type => :string
  def package (*name)
    Environment.new {|env|
      if !env[:ARCH] || !env[:KERNEL] || !env[:LIBC] || !env[:COMPILER]
        fatal "You have to set ARCH, KERNEL, LIBC and COMPILER to build packages."
        exit 1
      end
    }

    name.map {|package|
      if package.end_with?('.rbuild')
        package
      else
        packages = _search(package, params['repository'])
  
        names = packages.group_by {|package|
          "#{package.tags}/#{package.name}"
        }.map {|(name, package)| name}.uniq
  
        if names.length == 0
          fatal "No package matches #{package}"

          exit 10
        elsif names.length > 1
          fatal "More than one package matches: #{package}"
  
          names.each {|name|
            puts "    #{name}"
          }
          
          exit 11
        end
  
        packages.sort {|a, b|
          a.version <=> b.version
        }.last
      end
    }.each {|package|
      if package.is_a?(String)
        path    = File.dirname(File.realpath(package))
        package = Package.parse(package.sub(/\.rbuild$/, ''))
      else
        path = "#{package.repository.path}/#{package.model.data.path}"
      end

      manifest = Nokogiri::XML.parse(File.read("#{path}/digest.xml"))

      files = {}
      manifest.xpath('//files/file').each {|e|
        files[e['name']] = e.text
      }

      begin; package = loadPackage(path, package); rescue LoadError; end

      if !package
        fatal 'The package could not be instantiated'
        exit 12
      end

      if package.parent.nil?
         warn 'The package does not have a parent'
      end

      package.path = path

      info "Building #{package}"

      output = File.realpath(params['output'])

      package.after :pack do |path|
        FileUtils.cp path, output, :preserve => true
      end

      if (File.read("#{package.directory}/.build") rescue nil) != package.to_s(:everything) || params['wipe']
        info "Cleaning #{package} because something changed."

        clean("#{package.to_s(:name)}-#{package.version}")

        package.create!

        begin
          File.write("#{package.directory}/.build", package.to_s(:everything))
        rescue; end
      end

      begin
        package.build {|stage|
          info "Executing #{stage.name}"
        }

        info "Succesfully built #{package}"
      rescue Exception => e
        fatal "Failed to build #{package}"
        Packo.debug e
      end
    }
  end

  desc 'Clean a package'
  opt 'tmp', 'The path to the temporary directory', :default => Environment[:TMP], :short_name => 't'
  def clean (*name)
    name.map {|package|
      if package.end_with?('.rbuild')
        package
      else
        packages = _search(package)

        if (multiple = packages.uniq).length > 1
          fatal 'Multiple packages with the same name, be more precise.'
          exit 2
        end

        packages.last
      end
    }.compact.each {|package|
      if package.is_a?(String)
        path    = File.dirname(File.realpath(package))
        package = Package.parse(package.sub(/\.rbuild$/, ''))
      else
        path = "#{package.repository.path}/#{package.model.data.path}"
      end

      begin
        loadPackage(path, package).clean!

        info "Cleaned #{package.to_s(:name)}"
      rescue Exception => e
        fatal "Failed cleaning of #{package.to_s(:name)}"
        Packo.debug e
      end
    }
  end

  desc 'Digest the given file'
  def digest (*file)
    file.each {|name|
      if !File.exists?(name)
        fatal "#{name} does not exist"
        exit! 40
      end

      Dir.chdir(File.dirname(name))

      name    = File.basename(name)
      package = Package.parse(name.sub(/\.rbuild$/, ''))
  
      begin
        package = loadPackage('.', package)
      rescue LoadError
        fatal 'Failed to load the rbuild'
        exit 80
      end

      package.after :fetch do |result|
        package.stages.stop!

        throw :halt
      end
    
      package.build

      original = Nokogiri::XML.parse(File.read('digest.xml')) rescue nil
  
      builder = Nokogiri::XML::Builder.new {|xml|
        xml.digest(:version => '1.0') {
          xml.build(:version => package.version, :slot => package.slot) {
            xml.features package.features.to_a.map {|f| f.name}.join(' ')

            xml.files {
              package.distfiles.each {|file|
                xml.file({ :name => File.basename(file) }, Digest::SHA1.hexdigest(File.read(file)))
              }
            }
          }

          if original
            original.xpath('//build').each {|build|
              if build['version'] != package.version.to_s && ((build['slot'].empty? && !package.slot) || build['slot'] != package.slot.to_s)
                xml.doc.root.add_child(build)
              end
            }
          end
        }
      }

      File.write('digest.xml', builder.to_xml(:indent => 4))
    }
  rescue Errno::EACCES
    fatal "Try to use `packo-build` instead of `packo build` (which is sandbox'd)"
  end

  desc 'Output the manifest of the given package'
  def manifest (package)
    if package.end_with?('.rbuild')
      package = loadPackage(File.dirname(package), Packo::Package.parse(package.sub('.rbuild', '')))
    else
      tmp = _search(package)

      if (multiple = tmp.uniq).length > 1
        fatal 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      package = loadPackage("#{tmp.last.repository.path}/#{tmp.last.model.data.path}", tmp.last)
    end

    if package
      puts RBuild::Package::Manifest.new(package).to_s
    else
      fatal 'Package could not be instantiated'
      exit 23
    end
  end

  private

  def _search (expression, repository=nil)
    packages = []

    if repository && !repository.empty?
      repository = Repository.first(Package::Repository.parse(repository).to_hash)

      if repository
        packages << repository.search(expression, true)
      end
    else
      Repository.all(:type => :source).each {|repository|
        packages << repository.search(expression, true)
      }
    end

    return packages.flatten.compact.map {|package|
      Package.wrap(package)
    }
  end
end

Application.dispatch
