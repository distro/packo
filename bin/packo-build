#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'
require 'rexml/document'
require 'digest/sha1'

require 'packo'
require 'packo_binary'
require 'packo/modules/packaging'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  desc 'Output version'
  def version
    puts "packÃ¸ building tool #{Packo::Version}"
  end

  desc 'Creates a package'
  opt 'tmp', 'The path to the temporary directory', :default => Packo::Environment[:TMP]
  opt 'output', 'The directory where to save packages', :default => Packo::Environment[:TMP]
  opt 'wipe', 'Wipes the package directory before building it', :type => :boolean, :default => false, :short_name => 'w'
  opt 'repository', 'Set a specific source repository', :type => :string
  def package (*name)
    Packo::Environment[:TMP] = params['tmp']

    name.map {|package|
      pkg = nil

      packages = _search(package, true, params['repository'])
      
      names = packages.group_by {|package|
        package.to_s
      }.map {|(name, package)| name}.uniq

      if names.length > 1
        fatal "More than one package matches: #{package}"
        names.each {|name|
          puts "    #{name}"
        }
        
        exit 10
      end

      packages.sort {|a, b|
        a.version <=> b.version
      }.last
    }.each {|package|
      path = "#{package.repository.path}/#{package.categories.join('/')}/#{package.name}"

      manifest = REXML::Document.new(File.read("#{path}/digest.xml"))

      files = {}
      manifest.elements.each('//files/file') {|e|
        files[e.attributes['name']] = e.text
      }

      begin
        loadPackage(path, package)
      rescue LoadError
        warn 'One of the rbuilds could not be found'
      end

      if !Packo::Packages[(package.categories + [package.name]).join('/')]
        warn 'The package does not have a parent'
      end

      package = Packo::Packages[package.to_s]

      if !package
        fatal 'The package could not be instantiated'
        exit 23
      end

      package.path = path

      info "Building #{package}"

      output = File.realpath(params['output'])

      package.on :packed do |path|
        FileUtils.cp path, output, :verbose => true, :preserve => true
      end

      if (File.read("#{package.directory}/.build") rescue nil) != package.to_s || params['wipe']
        info "Cleaning #{package} because flavors/features changed."

        clean(package.to_s)

        package.create!

        begin
          file = File.new("#{package.directory}/.build", 'w')
          file.write package.to_s
          file.close
        rescue; end
      end

      begin
        package.build {|stage|
          info "Executing #{stage.name}"
        }

        info "Succesfully built #{package}"
      rescue Exception => e
        fatal "Failed to build #{package}"
        Packo.debug e, :force => true
      end
    }
  end

  desc 'Clean a package'
  opt 'tmp', 'The path to the temporary directory', :default => Packo::Environment[:TMP]
  def clean (*name)
    name.map {|package|
      tmp = _search(package, true)

      if (multiple = tmp.uniq).length > 1
        fatal 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      begin
        path = "#{params['tmp']}/#{package.to_s(true)}/#{package.version}"

        FileUtils.rm_r "#{path}/work"; FileUtils.mkpath "#{path}/work"
        FileUtils.rm_r "#{path}/dist"; FileUtils.mkpath "#{path}/dist"
        FileUtils.rm_r "#{path}/temp"; FileUtils.mkpath "#{path}/temp"
      rescue Exception
      end
    }
  end

  desc 'Digest the given file'
  def digest (*file)
    file.each {|name|
      Dir.chdir(File.dirname(name))
      
      name = File.basename(name)
  
      if !File.exists? 'digest.xml'
        digest = REXML::Document.new
        digest.add_element REXML::Element.new('digest')
        digest.root.attributes['version'] = '1.0'
      else
        digest = REXML::Document.new(File.read('digest.xml'))
      end
  
      package = Packo::Package.parse(name.sub(/\.rbuild$/, ''))
  
      begin
        Packo.load "#{package.name}.rbuild" rescue nil
        Packo.load name
      rescue LoadError
        fatal 'Failed to load the rbuild'
        exit 80
      end
  
      package = Packo::Packages[:last]
  
      package.on :fetched, -9001 do
        package.stages.stop!
    
        raise 'YOU SHALL NOT PASS'
      end
    
      package.build
  
      digest.elements.each("//build[@version = '#{package.version}' AND @slot = '#{package.slot}']") {|e|
        e.parent.delete(e)
      }
    
      build                       = REXML::Element.new('build')
      build.attributes['version'] = package.version.to_s
      build.attributes['slot']    = package.slot.to_s
    
      features = REXML::Element.new('features')
  
      features.text = package.features.each {}.map {|f| f.first.to_s}.join(' ')
  
      files = REXML::Element.new('files')
      package.distfiles.each {|file|
        files.add_element((dom = REXML::Element.new('file');
          dom.attributes['name'] = File.basename(file);
          dom.text               = Digest::SHA1.hexdigest(File.read(file));
          dom
        ))
      }
            
      build.add_element features
      build.add_element files
    
      digest.root.add_element build
    
      file = File.new('digest.xml', 'w')
      digest.write file
      file.close
    }
  rescue Errno::EACCES
    fatal "Try to use `packo-build` instead of `packo build` (which is sandbox'd)"
  end

  desc 'Output the manifest of the given package'
  def manifest (package)
    tmp = _search(package, true)

    if (multiple = tmp.uniq).length > 1
      fatal 'Multiple packages with the same name, be more precise.'
      exit 2
    end

    package = tmp.last

    loadPackage("#{package.repository.path}/#{package.categories.join('/')}/#{package.name}", package)

    if Packo::Packages[package.to_s]
      puts Packo::Package::Manifest.new(Packo::Packages[package.to_s]).to_s(4)
    else
      fatal 'Package could not be instantiated'
      exit 23
    end
  end

  private

  def _search (package, exact=false, repository='')
    `packo-repository --repository='#{repository}' --type=source --exact=#{exact.inspect} --full=true search '#{package}'`.lines.map {|line|
      matches = line.match(%r{^(.*?)\s*\((.*?)/(.*?) \| (.*?)\)$})

      pkg = Packo::Package.parse(matches[1])

      PackoBinary::Package.new(pkg.categories.join('/'), pkg.name, pkg.version, pkg.slot, OpenStruct.new(
				:type => matches[2],
        :name => matches[3],
        :path => matches[4]
      ))
    }.compact
  end
end

Application.dispatch
