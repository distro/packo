#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'
require 'rexml/document'
require 'digest/sha1'

require 'packo'
require 'packo_binary'
require 'packo/modules/packaging'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  class_opt 'database', 'The path to the database', :default => Packo::Environment[:BUILD_CACHE]

  desc 'Output version'
  def version
    puts "packÃ¸ building tool #{Packo::Version}"
  end

  desc 'Create a package'
  opt 'tmp', 'The path to the temporary directory', :default => Packo::Environment[:TMP]
  opt 'output', 'The directory where to save packages', :default => Packo::Environment[:TMP]
  opt 'wipe', 'Wipes the package directory before building it', :type => :boolean, :default => false, :short_name => 'w'
  def create (*name)
    Packo::Environment[:TMP] = params['tmp']

    name.map {|package|
      tmp = []

      PackoBinary::Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << PackoBinary::Package.new(pkg['categories'], pkg['name'], pkg['version'], pkg['slot'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        fatal 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      path = "#{package.tree.path}/#{package.categories.join('/')}/#{package.name}"

      manifest = REXML::Document.new(File.new("#{path}/digest.xml"))

      files = {}
      manifest.elements.each('//files/file') {|e|
        files[e.attributes['name']] = e.text
      }

      begin
        loadPackage(path, package)
      rescue LoadError
        warn 'One of the rbuilds could not be found'
      end

      if !Packo::Packages[(package.categories + [package.name]).join('/')]
        warn 'The package does not have a parent'
      end

      package      = PackoBinary::Package.envify(Packo::Packages[package.to_s])
      package.path = path

      if !package
        fatal 'Package could not be instantiated'
        exit 23
      end

      info "Building #{package}"

      output = File.realpath(params['output'])

      package.on :packed do |path|
        FileUtils.cp path, output, :verbose => true, :preserve => true
      end

      if (File.read("#{package.directory}/.build") rescue nil) != package.to_s || params['wipe']
        info "Cleaning #{package} because flavors/features changed."

        clean(package.to_s)

        package.create!

        begin
          file = File.new("#{package.directory}/.build", 'w')
          file.write package.to_s
          file.close
        rescue; end
      end

      begin
        package.build {|stage|
          info "Executing #{stage.name}"
        }

        info "Succesfully built #{package}"
      rescue Exception => e
        fatal "Failed to build #{package}"
        Packo.debug e, :force => true
      end
    }
  end

  desc 'Clean a package'
  opt 'tmp', 'The path to the temporary directory', :default => Packo::Environment[:TMP]
  def clean (*name)
    name.map {|package|
      tmp = []

      PackoBinary::Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << PackoBinary::Package.new(pkg['categories'], pkg['name'], pkg['version'], pkg['slot'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        fatal 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      begin
        path = "#{params['tmp']}/#{package.to_s(true)}/#{package.version}"

        FileUtils.rm_r "#{path}/work"; FileUtils.mkpath "#{path}/work"
        FileUtils.rm_r "#{path}/dist"; FileUtils.mkpath "#{path}/dist"
        FileUtils.rm_r "#{path}/temp"; FileUtils.mkpath "#{path}/temp"
      rescue Exception
      end
    }
  end

  desc 'Searches packages with the given expression'
  opt 'exact', 'Search for the exact name', :type => :boolean, :default => false
  def search (expression='')
    PackoBinary::Tree.all(@db).each {|tree|
      tree.search(expression, params['exact']).each {|package|
        puts PackoBinary::Package.new(package['categories'], package['name'], package['version'], package['slot']).to_s
      }
    }
  end

  desc 'Updates the cache file'
  opt 'wipe', 'Wipes the cache before updating it', :type => :boolean, :default => false, :short_name => 'w'
  def cache (*tree)
    if params['wipe']
      FileUtils.rm(params['cache']) rescue nil

      @db = SQLite3::Database.new(params['cache'])
      @db.results_as_hash = true
    end

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS trees (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
  
        name TEXT,
        path TEXT,
  
        UNIQUE (name)
      )
    })
  
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS packages ( 
        tree INTEGER,

        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT,

        description TEXT,
        homepage TEXT,
        license TEXT,

        UNIQUE (categories, name, version, slot)
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS package_features (
        package_categories TEXT,
        package_name       TEXT,
        package_version    TEXT,
        package_slot       TEXT,

        name TEXT,
        description TEXT,

        enabled INTEGER,

        UNIQUE (package_categories, package_name, package_version, package_slot, name)
      )
    })

    begin
      tree.each {|tree|
        PackoBinary::Tree.create(@db, REXML::Document.new(File.new("#{tree}/repository.xml")), File.realpath(tree)).update
      }
    rescue Exception => e
      fatal "Failed to update cache"
      Packo.debug e, :force => true
    end
  
    @db.commit rescue nil

    info "Updated cache succesfully"
  end

  desc 'Create a manifest for the given packages'
  def digest (*name)
    name.map {|package|
      tmp = []

      PackoBinary::Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << PackoBinary::Package.new(pkg['categories'], pkg['name'], pkg['version'], pkg['slot'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        fatal 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp
    }.each {|packages|
      info "Digesting #{packages.first}"

      packages.group_by {|package|
        package.tree
      }.each {|tree, packages|
        digest = REXML::Document.new
        digest.add_element REXML::Element.new('digest')
        digest.root.attributes['version'] = '1.0'
  
        path = "#{tree.path}/#{packages.first.categories.join('/')}/#{packages.first.name}"
  
        begin
          Packo.load "#{path}/#{packages.first.name}.rbuild"
        rescue LoadError
          warn 'The root rbuild could not be found'
        end
        
        packages.each {|package|
          info "doing #{package.version}..."
  
          begin
            Packo.load "#{path}/#{package.name}-#{package.version}.rbuild"
          rescue LoadError
            warn "Failed to load #{package}"
            next
          end
  
          package = PackoBinary::Package.envify(Packo::Packages[package.to_s])
  
          if !package
            fatal 'Package could not be instantiated'
            exit 23
          end
  
          dom                          = REXML::Element.new('package')
          dom.attributes['name']       = package.name
          dom.attributes['categories'] = package.categories.join('/')
          dom.attributes['version']    = package.version
          dom.attributes['slot']       = package.slot
  
          features = REXML::Element.new('features')
          package.features.each {|feature|
            tmp      = REXML::Element.new('feature')
            tmp.text = feature.name
  
            features.add_element tmp
          }
  
          package.on :unpack, -9001 do
            package.stages.stop!
  
            raise 'YOU SHALL NOT PASS'
          end
  
          package.build
  
          files = REXML::Element.new('files')
          package.distfiles.each {|file|
            tmp                    = REXML::Element.new('file')
            tmp.attributes['name'] = File.basename(file)
            tmp.text               = Digest::SHA1.hexdigest(File.read(file))
  
            files.add_element tmp
          }
          
          dom.add_element features
          dom.add_element files
  
          digest.root.add_element dom
        }
  
        file = File.new("#{path}/digest.xml", 'w')
        digest.write file
        file.close

        info "Digested #{packages.first} (#{file.path})"
      }
    }
  end

  desc 'Output the manifest of the given package'
  def manifest (package)
    tmp = []

    PackoBinary::Tree.all(@db).each {|tree|
      tree.search(package, true).each {|pkg|
        tmp << PackoBinary::Package.new(pkg['categories'], pkg['name'], pkg['version'], pkg['slot'], tree)
      }
    }

    if (multiple = tmp.uniq).length > 1
      fatal 'Multiple packages with the same name, be more precise.'
      exit 2
    end

    package = tmp.last

    loadPackage("#{package.tree.path}/#{package.categories.join('/')}/#{package.name}", package)

    if Packo::Packages[package.to_s]
      puts Packo::Package::Manifest.new(Packo::Packages[package.to_s]).to_s(4)
    else
      fatal 'Package could not be instantiated'
      exit 23
    end
  end

  def params= (params)
    @params = params

    if File.directory? params['database']
      fatal "#{params['database']} is a directory"
      exit 42
    end

    begin
      FileUtils.mkpath(File.dirname(params['database']))
    rescue Exception => e
      fatal "Could not create #{File.dirname(params['database'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['database'])
    @db.results_as_hash = true
  end
end

Application.dispatch
