#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'open-uri'
require 'nokogiri'

require 'packo'
require 'packo/binary'

class Application < Optitron::CLI
  include Packo
  include Binary::Helpers
  include Models

  @@scm = ['git'] # implement others

  desc 'Outputs version'
  def version
    puts "packÃ¸ repository manager #{VERSION}"
  end

  desc 'Adds binary/source repositories'
  def add (*uri)
    uri.each {|uri|
      uri  = URI.parse(uri)
      kind = nil
      type = nil
      name = nil

      if uri.scheme.nil? || uri.scheme == 'file'
        kind = :file

        if File.directory? uri.path
          dom = Nokogiri::XML.parse(File.read("#{uri.path}/repository.xml"))
        else
          dom = Nokogiri::XML.parse(File.read(uri.path))
        end

        uri = File.realpath(uri.path)

        type = dom.root['type'].to_sym
        name = dom.root['name']
      elsif ['http', 'https', 'ftp'].member?(uri.scheme)
        kind = :fetched

        xml = open(uri).read
        dom = Nokogiri::XML.parse(xml)

        type = dom.root['type'].to_sym
        name = dom.root['name']
      elsif @@scm.member?(uri.scheme)
        kind = :scm

        FileUtils.rm_rf("#{Environment[:TMP]}/.__repo", :secure => true)

        _checkout(uri, "#{Environment[:TMP]}/.__repo")

        dom = Nokogiri::XML.parse(File.read("#{Environment[:TMP]}/.__repo/repository.xml"))

        type = dom.root['type'].to_sym
        name = dom.root['name']
      end

      if !kind
        fatal "I don't know what to do with #{uri}"
        next
      end

      path = "#{Environment[:REPOSITORIES]}/#{type}/#{name}"

      if Repository.first(:type => type, :name => name)
        fatal "#{type}/#{name} already exists, delete it first"
        exit! 10
      end

      case type
        when :binary
          path << '.xml'

          FileUtils.mkpath(File.dirname(path))

          file = File.new(path, 'w')
          file.write(open(kind == :file && !uri.to_s.match(/\.xml$/) ? "#{uri}/repository.xml" : uri).read)
          file.close

        when :source
          FileUtils.rm_rf path, :secure => true rescue nil
          FileUtils.mkpath path rescue nil

          case kind
            when :fetched
              _checkout(dom.xpath('//address').first.text, path)

            when :scm
              FileUtils.cp_r "#{Environment[:TMP]}/.__repo/.", path, :preserve => true

            else
              _checkout(uri.to_s, path)
          end
      end

      begin
        _add type, name, uri, path
        _info "Added #{type}/#{name}"
      rescue Exception => e
        fatal 'Failed to add the cache'
        Packo.debug e, :force => true

        if (repository = Repository.first(:type => type, :name => name))
          repository.destroy
        end
      end
    }

    @db.commit rescue nil
  end

  desc 'Deletes installed repositories'
  def delete (*name)
    name.each {|name|
      repository = Package::Repository.parse(name)

      if repository.type && !Package::Repository::Types.member?(repository.type)
        fatal "#{repository.type} is not a valid repository type"
        exit! 20
      end

      conditions        = Hash[:name => repository.name]
      conditions[:type] = repository.type if repository.type

      repositories = Repository.all(conditions)

      if repositories.empty?
        fatal "#{repository.type}/#{repository.name} doesn't exist"
        exit! 21
      end

      _info "Deleting #{[repository.type, repository.name].join('/')}"

      begin
        repositories.each {|repository|
          FileUtils.rm_rf repository.path, :secure => true

          repository.destroy
        }
      rescue Exception => e
        fatal "Something went wrong while deleting #{name}"

        Packo.debug e, :force => true
      end
    }
  end

  desc 'Updates installed repositories'
  def update
    Repository.all.each {|repository|
      updated = false

      type = repository.type
      name = repository.name
      uri  = repository.uri.to_s
      path = repository.path

      case repository.type
        when :binary
          if (content = open(uri).read) != File.read(path)
            repository.destroy
            file = File.new(path, 'w')
            file.write(content)
            file.close
            _add(:binary, name, uri, path)

            updated = true
          end

        when :source
          if _update(path)
            repository.destroy
            _add(:source, name, uri, path)

            updated = true
          end

        when :virtual
      end

      if updated
        _info "Updated #{type}/#{name}"
      else
        _info "#{type}/#{name} already up to date"
      end
    }
  end

  desc 'Searches packages with the given expression'
  opt 'exact', 'Search for the exact name', :type => :boolean, :default => false, :short_name => 'e'
  opt 'full', 'Include the repository that owns the package', :type => :boolean, :default => false
  opt 'type', 'The repository type', :type => :string, :in => ['source', 'binary', 'all'], :default => 'all', :short_name => 't'
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def search (expression='')
    _search(expression, params['exact'], params['repository'], params['type']).uniq.group_by {|package|
      "#{package.tags}/#{package.name}"
    }.sort.each {|(name, packages)|
      packages.sort {|a, b|
        a.version <=> b.version
      }.each {|package|
        print "#{package.tags}/#{colorize(package.name, :DEFAULT, :DEFAULT, :BOLD)}"
        print "-#{colorize(package.version, :RED)}"
        print "%#{colorize(package.slot, :BLUE, :DEFAULT, :BOLD)}" if package.slot

        print " (#{package.repository.type}/#{package.repository.name} | #{package.repository.uri} | #{package.repository.path})" if params['full']
        print "\n"
      }
    }
  end

  desc 'Searches packages with the given expression and returns detailed informations about them'
  opt 'exact', 'Search for the exact name', :type => :boolean, :default => false, :short_name => 'e'
  opt 'type', 'The repository type', :type => :string, :in => ['source', 'binary', 'all'], :default => 'all', :short_name => 't'
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def info (expression='')
    _search(expression, params['exact'], params['repository'], params['type']).group_by {|package|
      package.name
    }.sort.each {|(name, packages)|
      packages.sort {|a, b|
        a.version <=> b.version
      }.each {|package|
        print "[#{colorize("source/#{package.repository.name}", :BLACK, :DEFAULT, :BOLD)}] "
        print colorize(package.name, :DEFAULT, :DEFAULT, :BOLD)
        print "-#{colorize(package.version, :RED)}"
        print " (#{colorize(package.slot, :BLUE, :DEFAULT, :BOLD)})" if package.slot
        print " [#{colorize(package.tags.join(' '), :MAGENTA)}]"
        print "\n"

        puts "    #{colorize('Description', :GREEN)}: #{package.description}"
        puts "    #{colorize('Homepage', :GREEN)}:    #{package.homepage}"
        puts "    #{colorize('License', :GREEN)}:     #{package.license}"
        puts "    #{colorize('Maintainer', :GREEN)}:  #{package.model.maintainer || 'nobody'}"

        case package.repository.type
          when :binary
            puts "    #{colorize('Features', :GREEN)}:    #{package.features.to_a.select {|f| f.enabled?}.map {|f| f.name}.join(' ')}"

            print "    #{colorize('Builds', :GREEN)}:      "
            package.model.data.builds.each {|build|
              print 'With '

              if !build.features.empty?
                print colorize(build.features, :DEFAULT, :DEFAULT, :BOLD)
              else
                print 'nothing'
              end

              print " in #{colorize(build.flavor, :DEFAULT, :DEFAULT, :BOLD)} flavor" if build.flavor
              print colorize(" (SHA1 #{build.digest})", :BLACK, :DEFAULT, :BOLD) if build.digest
              print "\n                 "
            }

          when :source
            next unless package.model.data.features.length > 0

            print "    #{colorize('Features', :GREEN)}:    "

            features = package.model.data.features
            length   = features.map {|feature| feature.name.length}.max

            features.each {|feature|
              if feature.enabled
                print "#{colorize(feature.name, :WHITE, :DEFAULT, :BOLD)}#{Environment[:NO_COLORS] ? '!' : ''}"
              else
                print colorize(feature.name, :BLACK, :DEFAULT, :BOLD)
              end

              print "#{' ' * (4 + length - feature.name.length + (Environment[:NO_COLORS] && !feature.enabled ? 1 : 0))}#{feature.description || '...'}"

              print "\n                 "
            }
        end

        print "\n"
      }
    }
  end

  desc 'Shows installed repositories'
  def show (type='all')
    if Package::Repository::Types.member?(type.to_sym)
      _info "Installed #{type} repositories:"

      repositories = Repository.all(:type => type)
      length       = repositories.map {|repository| "#{repository.type}/#{repository.name}".length}.max

      repositories.each {|repository|
        puts "  #{repository.type}/#{repository.name}#{' ' * (4 + length - "#{repository.type}/#{repository.name}".length)}#{repository.uri} (#{repository.path})"
      }

      puts ''
    elsif type == 'all'
      Package::Repository::Types.each {|type|
        show(type)
      }
    end
  end

  desc 'Outputs the path of a given repository'
  def path (name)
    repository = Repository.first(Package::Repository.parse(name).to_h)

    exit! if !repository

    puts repository.path
  end

  desc 'Outputs the URI of a given package'
  def uri (name)
    repository = Repository.first(Package::Repository.parse(name).to_h)

    exit! if !repository

    puts repository.URI
  end

  desc 'Rehash the repository caches'
  def rehash (*names)
    repositories = []

    if names.empty?
      repositories << Repository.all
    else
      names.each {|name|
        repositories << Repository.all(:name => name)
      }
    end

    repositories.flatten.compact.each {|repository|
      type = repository.type
      name = repository.name
      uri  = repository.uri
      path = repository.path

      _info "Rehashing #{type}/#{name}"

      repository.destroy

      case type
        when :binary
          _add(:binary, name, uri, path)

        when :source
          _add(:source, name, uri, path)
      end
    }
  end

  private

  def _search (expression, exact=false, name=nil, type=nil)
    packages = []

    if name && !name.empty?
      repository      = Package::Repository.parse(name)
      repository.type = type if Package::Repository::Types.member?(type.to_sym)
      repository      = Repository.first(repository.to_h)

      if repository
        packages << repository.search(expression, params['exact'])
      end
    else
      Package::Repository::Types.each {|t|
        if type.nil? || type == 'all' || type == t.to_s
          Repository.all(:type => t).each {|repository|
            packages << repository.search(expression, exact)
          }
        end
      }
    end

    return packages.flatten.compact.map {|package|
      Package.wrap(package)
    }
  end

  def _add (type, name, uri, path)
    Binary::Repository.wrap(Repository.new(
      :type => type,
      :name => name,

      :uri  => uri,
      :path => path
    )).populate
  end

  def _delete (name, type)
    Repository.first(:name => name, :type => type).destroy
  end

  def _checkout (uri, path)
    uri = URI.parse(uri.to_s) if !uri.is_a?(URI)

    if !uri.scheme
      if File.directory?("#{uri}/.git")
        scm = 'git'
      end
    else
      scm = uri.scheme
    end

    if !@@scm.member?(scm)
      fatal "#{scm} is an unsupported SCM"
      exit 40
    end

    case scm
      when 'git'; Packo.sh 'git', 'clone', uri.to_s, path, :silent => !Environment[:VERBOSE]
    end
  end

  def _update (path)
    result = false

    old = Dir.pwd; Dir.chdir(path)

    if !result && (`git pull`.strip != 'Already up-to-date.' rescue nil)
      result = true
    end

    Dir.chdir(old)

    return result
  end
end

Application.dispatch
