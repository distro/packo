#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'
require 'open-uri'
require 'digest/sha1'
require 'find'

require 'packo'
require 'packo/modules/packaging'
require 'packo_binary'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  class_opt 'database', 'The path to the database', :default => Packo::Environment[:CACHE]

  desc 'Outputs version'
  def version
    puts "packø #{Packo::Version}"
  end

  desc 'Installs packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/'
  opt 'inherit', 'Apply the passed flags to the eventual dependencies', :type => :boolean, :default => false
  opt 'force', 'Force installation when something minor goes wrong', :type => :boolean, :default => false
  opt 'nodeps', 'Ignore blockers and dependencies', :type => :boolean, :default => false
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def install (*name)
    _database

    outside = params['destination'] != '/'

    FileUtils.mkpath params['destination'] rescue nil
    FileUtils.mkpath Packo::Environment[:SELECTOR_MODULES] rescue nil

    binary = false

    if name.last === true
      manual = name.shift ? 0 : 1
    else
      manual = 1
    end

    name.each {|name|
      if File.extname(name).empty?
        packages = nil
  
        if Packo::Environment.new[:FLAVOR].include?('binary')
          packages = _search(name, :binary, params['repository'])
  
          if packages.empty?
            warn "#{name} could not be found in the binary repositories, looking in source repositories"
            packages = nil
          else
            binary = true
          end
        end
  
        begin
          if !packages
            packages = _search(name, :source, params['repository'])
  
            binary = false
          end
  
          names = packages.group_by {|package|
            "#{package.categories.join('/')}/#{package.name}"
          }.map {|(name, package)| name}.uniq
  
          if names.length > 1
            fatal "More than one package matches: #{name}"
            names.each {|name|
              puts "    #{name}"
            }
          
            exit 10
          end
  
          package = packages.sort {|a, b|
            a.version <=> b.version
          }.last
  
          if !package
            fatal "#{name} not found"
            exit! 11
          end
  
          env = Packo::Environment.new(package)
  
          _filter(package, env)
  
          if package.repository.type == :binary && !_has(package, env)
            warn 'The binary package is not available with the features you asked for, trying to build from source'
            packages = nil
            raise ArgumentError
          end
        rescue ArgumentError
          retry
        end
  
        case package.repository.type
          when :binary
            name = "#{package.categories.join('/')}/#{package.name}-#{package.version}"
  
            flavors = ''
            env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.each {|f|
              flavors << ".#{f}"
            }
            flavors[0, 1] = ''
  
            features = ''
            env[:FEATURES].split(/\s+/).each {|f|
              features << "-#{f}"
            }
            features[0, 1] = ''
  
            name << "%#{package.slot}"
            name << "+#{flavors}"
            name << "-#{features}"
            name << ".pko"
  
            FileUtils.mkpath(File.dirname("#{env[:TMP]}/#{name}")) rescue nil
  
            begin
              Packo.sh 'wget', '-c', '-O', "#{env[:TMP]}/#{name}", "#{_uri(package.repository)}/#{name}"
            rescue RuntimeError
              FileUtils.rm "#{env[:TMP]}/#{name}"
              fatal "Failed to download #{name}"
              exit! 12
            end
  
            name = "#{env[:TMP]}/#{name}"
  
            if (digest = _digest(package, env)) && (result = Digest::SHA1.hexdigest(File.read(name))) != digest
              fatal "Digest mismatch (got #{result} expected #{digest}), install this package from source, the mirror could be compromised"
              exit 99
            end
  
            path = "#{env[:TMP]}/.__packo_unpacked/#{name[env[:TMP].length, name.length]}"
  
          when :source
            name = _build(package, env)
            path = "#{env[:TMP]}/.__packo_unpacked/#{package.categories.join('/')}/#{name[env[:TMP].length + '.__packo_build/'.length, name.length]}"
        end
      else
        env  = Packo::Environment.new
        path = "#{env[:TMP]}/.__packo_unpacked/#{File.basename(name)}"
      end

      FileUtils.rm_rf path, :secure => true

      case File.extname(name)
        when '.pko'
          Packo::Modules::Packaging::PKO.unpack(File.realpath(name), path)

          manifest = Packo::Package::Manifest.open("#{path}/manifest.xml")

        else
          fatal 'Unknown package type'
          exit! 14
      end

      if !params['inherit']
        Packo::Environment[:FLAVOR] = Packo::Environment[:FEATURES] = ''
      end

      if !params['nodeps']
        manifest.blockers {|blocker|
          if (blocker.runtime? || !binary) && _installed?(blocker)
            fatal "#{blocker} can't be installed with #{package}"
            exit! 15
          end
        }

        manifest.dependencies.each {|dependency|
          install(dependency.to_s) if dependency.runtime? || !binary
        }
      end

      manifest.selectors.each {|selector|
        FileUtils.cp_r "#{path}/selectors/#{selector.path}", env[:SELECTOR_MODULES], :preserve => true, :remove_destination => true
        Packo.sh 'packo-select', 'add', selector.name, selector.description, "#{env[:SELECTOR_MODULES]}/#{selector.path}", :silent => true
      }

      if !(outside && !params['force'])
        begin
          @db.execute('INSERT OR ABORT INTO packages VALUES(NULL, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)', [params['repository'],
            manifest.package.categories.join('/'), manifest.package.name, manifest.package.version.to_s, manifest.package.slot.to_s, manifest.package.revision,
            manifest.package.flavors, manifest.package.features, manual, 1
          ])

          id = @db.execute('SELECT id FROM packages WHERE categories = ? AND name = ? AND slot = ?', [
            manifest.package.categories.join('/'), manifest.package.name, manifest.package.slot.to_s
          ]).first['id']
        rescue SQLite3::ConstraintException
          fatal "#{manifest.package.categories.join('/')}/#{manifest.package.name} is already installed"
          exit! 16
        end
      end

      length = "#{path}/dist".length

      begin
        Find.find("#{path}/dist") {|file|
          type = nil
          path = "#{params['destination']}/#{file[length, file.length]}".gsub(%r{/*/}, '/')
          fake = path[params['destination'].length, path.length]
          meta = nil

          if !outside && pkg = _exists?(fake) && !params['force']
            fatal "#{path} belongs to #{pkg}, use --force to force overwrite"
            raise RuntimeError.new 'File collision'
          end
  
          if File.directory? file
            type = 'dir'
            FileUtils.mkpath path
          elsif File.symlink? file
            type = 'sym'
            meta = File.readlink file

            FileUtils.rm_f path
            File.symlink meta, path
          elsif File.file? file
            type = 'obj'
            meta = Digest::SHA1.hexdigest(File.read(file))
            FileUtils.cp file, path, :preserve => true
          else
            next
          end

          case type
            when 'dir'; puts colorize(">   #{path}", :DEFAULT, :DEFAULT, :BOLD)
            when 'sym'; puts colorize(">>> #{path} -> #{meta}", :BLUE, :DEFAULT, :BOLD)
            when 'obj'; puts ">>> #{path}"
          end
  
          if !(outside && !params['force'])
            @db.execute('INSERT INTO contents VALUES(?, ?, ?, ?)', [id, type, fake, meta])
          end
        }
      rescue Exception => e
        if !(outside && !params['force'])
          @db.execute('DELETE FROM packages WHERE id = ?', id)
          @db.execute('DELETE FROM contents WHERE package = ?', id)
        end

        fatal 'Something went deeply wrong when installing package contents'
        Packo.debug e, :force => true
        exit! 17
      end
    }
  end

  desc 'Uninstalls packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/'
  def uninstall (*name)
    _database

    name.each {|name|
      _search_installed(name).each {|installed|
        @db.execute('SELECT * FROM contents WHERE package = ? ORDER BY type DESC', installed['package']).each {|content|
          path = "#{params['destination']}/#{content['path']}".gsub(%r{/*/}, '/')

          case content['type']
            when 'obj'
              puts "<<< #{path}"
              FileUtils.rm_f(path)

            when 'sym'
              puts colorize("<<< #{path} -> #{meta}", :BLUE, :DEFAULT, :BOLD)
              FileUtils.rm_f(path)

            when 'dir'
              puts colorize("<   #{path}", :DEFAULT, :DEFAULT, :BOLD)
              Dir.delete(path) rescue nil
          end

          @db.execute('DELETE FROM contents WHERE package = ? AND path = ?', [content['package'], content['path']])
        }

        @db.execute('DELETE FROM packages WHERE id = ?', installed['id'])

        @db.execute('DELETE FROM dependencies WHERE package = ?', installed['id'])
      }
    }
  end

  def show
    @db.execute('SELECT * FROM packages').each {|package|
      print "#{package['categories']}/#{colorize(package['name'], :DEFAULT, :DEFAULT, :BOLD)}"
      print "-#{colorize(package['version'], :RED)}"
      print "%#{colorize(package['slot'], :BLUE, :DEFAULT, :BOLD)}" if !package['slot'].empty?

      print " [#{package['features']}]" if !package['features'].empty?
      print " {#{package['flavors']}}" if !package['flavors'].empty?
    }
  end

  desc 'Manages packø building system'
  def build (*argument)
    cmd = "sandbox packo-build"

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages various configurations'
  def select (*argument)
    cmd = 'packo-select'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø repositories'
  def repository (*argument)
    cmd = 'sandbox packo-repository'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages packø environment'
  def env (*argument)
    cmd = 'packo-env'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  def params= (params)
    @params = params

    if File.directory? params['database']
      fatal "#{params['database']} is a directory"
      exit 42
    end

    begin
      FileUtils.mkpath(File.dirname(params['database']))
    rescue Exception => e
      fatal "Could not create #{File.dirname(params['database'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['database'])
    @db.results_as_hash = true
  end

  private

  def _database
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS packages (
        id INTEGER PRIMARY KEY AUTOINCREMENT,

        repository TEXT,

        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT,
        revision   INTEGER,

        flavors  TEXT,
        features TEXT,

        manual  INTEGER DEFAULT 0,
        runtime INTEGER DEFAULT 1,

        UNIQUE (categories, name, slot)
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS dependencies (
        package    INTEGER,
        dependency INTEGER
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS contents (
        package INTEGER,

        type TEXT,
        path TEXT,
        meta TEXT
      )
    })
  end

  def _installed? (package)
    @db.execute('SELECT * FROM installed WHERE categories = ? AND name = ? AND version = ? AND slot = ?', [
      package.categories.join('/'), package.name, package.version.to_s, package.slot.to_s
    ]).first
  end

  def _search_installed (expression, exact=false)
    if matches = expression.match(/^([<>]?=?)/)
      validity = ((matches[1] && !matches[1].empty?) ? matches[1] : nil)
      expression = expression.sub(/^([<>]?=?)/, '')

      validity = nil if validity == '='
    else
      validity = nil
    end

    package = Packo::Package.parse(expression)

    if !exact
      result = @db.execute(%{
        SELECT *

        FROM packages

        WHERE #{[
          (!package.categories.empty?) ? 'categories LIKE ?' : nil,
          (package.name) ? 'name LIKE ?' : nil,
          (package.version && !validity) ? 'version LIKE ?' : nil
        ].compact.join(' AND ')}
      }, [
        (!package.categories.empty? ? "%#{package.categories.join('/')}%" : nil),
        (package.name ? "%#{package.name}%" : nil),
        (package.version && !validity ? "%#{package.version}%" : nil)
      ].compact)
    else
      result = @db.execute(%{
        SELECT *

        FROM packages

        WHERE  #{[
          (!package.categories.empty?) ? 'categories = ?' : nil,
          (package.name) ? 'name = ?' : nil,
          (package.version && !validity) ? 'version = ?' : nil
        ].compact.join(' AND ')}
      }, [
        (package.categories.empty? ? nil : package.categories.join('/')),
        package.name,
        package.version && !validity ? package.version : nil 
      ].compact)
    end

    return result if !validity

    result.select {|pkg|
      case validity
        when '>';  Versionomy.parse(pkg['version']) >  package.version
        when '>='; Versionomy.parse(pkg['version']) >= package.version
        when '<';  Versionomy.parse(pkg['version']) <  package.version
        when '<='; Versionomy.parse(pkg['version']) <= package.version
      end
    }
  end

  def _search (package, type, repository=nil)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository #{"--repository='#{repository}'" if repository} --type='#{type}' --full=true search '#{package}'`.lines.map {|line|
        matches = line.match(%r{^(.*?)\s*\((.*?)/(.*?) \| (.*?) \| (.*?)\)$})

        next if !matches

        pkg = Packo::Package.parse(matches[1])

        PackoBinary::Package.new(pkg.categories.join('/'), pkg.name, pkg.version, pkg.slot, OpenStruct.new(
	  			:type => matches[2].to_sym,
          :name => matches[3],
          :uri  => matches[4],
          :path => matches[5]
        ))
      }.compact
    }
  end

  def _uri (repository)
    `packo-repository uri '#{repository.type}/#{repository.name}'`.strip
  end

  def _build (package, env)
    FileUtils.rm_rf "#{env[:TMP]}/.__packo_build", :secure => true rescue nil
    FileUtils.mkpath "#{env[:TMP]}/.__packo_build" rescue nil

    if !system("sandbox packo-build --output='#{env[:TMP]}/.__packo_build' --repository='#{package.repository.type}/#{package.repository.name}' package #{package.to_s}")
      raise RuntimeError.new 'Build failed'
    end

    return Dir.glob("#{env[:TMP]}/.__packo_build/#{package.name}-#{package.version}*.pko").first
  end

  def _has (package, env)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.include?(
        %{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip
      )
    }
  end

  def _filter (package, env)
    env[:FLAVOR] = env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.join(' ')

    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        /Features:\s+(.+)$/
      )
    }

    if !matches
      env[:FEATURES] = ''
    else
      features       = matches[1].split(/\s+/)
      env[:FEATURES] = env[:FEATURES].split(/\s+/).delete_if {|f|
        !features.member?(f)
      }.join(' ')
    end
  end

  def _digest (package, env)
    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        %r{#{Regexp.escape(%{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip)}.*?\(SHA1 (.*?)\)}
      )
    }

    return matches[1] if matches
  end

  def _exists? (path)
    path = @db.execute("SELECT * FROM contents WHERE path = ? AND type != 'dir'", path).first

    return false unless path

    @db.execute('SELECT * FROM packages WHERE id = ?', path['package']).first
  end
end

Application.dispatch
