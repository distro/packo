#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'
require 'open-uri'
require 'digest/sha1'

require 'packo'
require 'packo/modules/packaging'
require 'packo_binary'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  class_opt 'database', 'The path to the database', :default => Packo::Environment[:CACHE]

  desc 'Outputs version'
  def version
    puts "packø #{Packo::Version}"
  end

  desc 'Installs packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/'
  opt 'inherit', 'Apply the passed flags to the eventual dependencies', :type => :boolean, :default => false
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def install (*name)
    _database

    FileUtils.mkpath params['destination'] rescue nil
    FileUtils.mkpath Packo::Environment[:SELECTOR_MODULES] rescue nil

    binary = false

    name.each {|name|
      packages = nil

      if Packo::Environment.new[:FLAVOR].include?('binary')
        packages = _search(name, :binary, params['repository'])

        if packages.empty?
          warn "#{name} could not be found in the binary repositories, looking in source repositories"
          packages = nil
        else
          binary = true
        end
      end

      begin
        if !packages
          packages = _search(name, :source, params['repository'])

          binary = false
        end

        names = packages.group_by {|package|
          "#{package.categories.join('/')}/#{package.name}"
        }.map {|(name, package)| name}.uniq

        if names.length > 1
          fatal "More than one package matches: #{name}"
          names.each {|name|
            puts "    #{name}"
          }
        
          exit 10
        end

        package = packages.sort {|a, b|
          a.version <=> b.version
        }.last

        if !package
          fatal "#{name} not found"
          exit! 11
        end

        env = Packo::Environment.new(package)

        _filter(package, env)

        if package.repository.type == :binary && !_has(package, env)
          warn 'The binary package is not available with the features you asked for, trying to build from source'
          packages = nil
          raise ArgumentError
        end
      rescue ArgumentError
        retry
      end

      case package.repository.type
        when :binary
          name = "#{package.categories.join('/')}/#{package.name}-#{package.version}"

          flavors = ''
          env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.each {|f|
            flavors << ".#{f}"
          }
          flavors[0, 1] = ''

          features = ''
          env[:FEATURES].split(/\s+/).each {|f|
            features << "-#{f}"
          }
          features[0, 1] = ''

          name << "+#{flavors}" if !flavors.empty?
          name << "-#{features}" if !features.empty?
          name << "%#{package.slot}" if package.slot
          name << ".pko"

          FileUtils.mkpath(File.dirname("#{env[:TMP]}/#{name}")) rescue nil

          begin
            Packo.sh 'wget', '-c', '-O', "#{env[:TMP]}/#{name}", "#{_uri(package.repository)}/#{name}"
          rescue RuntimeError
            FileUtils.rm "#{env[:TMP]}/#{name}"
            fatal "Failed to download #{name}"
            exit! 12
          end

          name = "#{env[:TMP]}/#{name}"

          if (digest = _digest(package, env)) && (result = Digest::SHA1.hexdigest(File.read(name))) != digest
            fatal "Digest mismatch (got #{result} expected #{digest}), install this package from source, the mirror could be compromised"
            exit 99
          end

          path = "#{env[:TMP]}/.__packo_unpacked/#{name[env[:TMP].length, name.length]}"

        when :source
          name = _build(package, env)
          path = "#{env[:TMP]}/.__packo_unpacked/#{package.categories.join('/')}/#{name[env[:TMP].length + '.__packo_build'.length, name.length]}"
      end

      FileUtils.rm_rf path, :secure => true

      case File.extname(name)
        when '.pko'
          Packo::Modules::Packaging::PKO.unpack(File.realpath(name), path)

          manifest = Packo::Package::Manifest.open("#{path}/manifest.xml")

        else
          fatal 'Unknown package type'
          exit! 14
      end

      if !params['inherit']
        Packo::Environment[:FLAVOR] = Packo::Environment[:FEATURES] = ''
      end

      manifest.blockers {|blocker|
        if (blocker.runtime? || !binary) && _installed?(blocker)
          fatal "#{blocker} can't be installed with #{package}"
          exit! 15
        end
      }

      manifest.dependencies.each {|dependency|
        install(dependency.to_s) if dependency.runtime? || !binary
      }

      manifest.selectors.each {|selector|
        FileUtils.cp_r "#{path}/selectors/#{selector.path}", env[:SELECTOR_MODULES], :preserve => true, :remove_destination => true
        Packo.sh 'packo-select', 'add', selector.name, selector.description, "#{env[:SELECTOR_MODULES]}/#{selector.path}", :silent => true
      }

      FileUtils.cp_r Dir.glob("#{path}/dist/*"), params['destination'], :preserve => true, :remove_destination => true
    }
  end

  desc 'Uninstalls packages'
  def uninstall (*name)
    _database

  end

  def show
    @db.execute('SELECT * FROM present').each {|package|
      
    }
  end

  desc 'Manages packø building system'
  def build (*argument)
    cmd = "sandbox packo-build"

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages various configurations'
  def select (*argument)
    cmd = 'packo-select'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø repositories'
  def repository (*argument)
    cmd = 'sandbox packo-repository'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages packø environment'
  def env (*argument)
    cmd = 'packo-env'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  def params= (params)
    @params = params

    if File.directory? params['database']
      fatal "#{params['database']} is a directory"
      exit 42
    end

    begin
      FileUtils.mkpath(File.dirname(params['database']))
    rescue Exception => e
      fatal "Could not create #{File.dirname(params['database'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['database'])
    @db.results_as_hash = true
  end

  private

  def _database
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS installed (
        id INTEGER PRIMARY KEY AUTOINCREMENT,

        repository TEXT,

        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT DEFAULT NULL,

        flavors  TEXT,
        features TEXT,

        manual  INTEGER DEFAULT 0,
        runtime INTEGER DEFAULT 1,

        UNIQUE (categories, name, slot)
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS dependencies (
        package           INTEGER,
        needed_by_package INTEGER
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS files (
        package INTEGER,

        path TEXT
      )
    })
  end

  def _install

  end

  def _installed? (package)
    @db.execute('SELECT * FROM installed WHERE categories = ? AND name = ? AND version = ? AND slot = ?', [
      package.categories.join('/'), package.name, package.version.to_s, package.slot.to_s
    ]).first
  end

  def _search (package, type, repository=nil)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository #{"--repository='#{repository}'" if repository} --type='#{type}' --full=true search '#{package}'`.lines.map {|line|
        matches = line.match(%r{^(.*?)\s*\((.*?)/(.*?) \| (.*?) \| (.*?)\)$})

        next if !matches

        pkg = Packo::Package.parse(matches[1])

        PackoBinary::Package.new(pkg.categories.join('/'), pkg.name, pkg.version, pkg.slot, OpenStruct.new(
	  			:type => matches[2].to_sym,
          :name => matches[3],
          :uri  => matches[4],
          :path => matches[5]
        ))
      }.compact
    }
  end

  def _uri (repository)
    `packo-repository uri '#{repository.type}/#{repository.name}'`.strip
  end

  def _build (package, env)
    FileUtils.rm_rf "#{env[:TMP]}/.__packo_build", :secure => true rescue nil
    FileUtils.mkpath "#{env[:TMP]}/.__packo_build" rescue nil

    if !system("sandbox packo-build --output='#{env[:TMP]}/.__packo_build' --repository='#{package.repository.type}/#{package.repository.name}' package #{package.to_s}")
      raise RuntimeError.new 'Build failed'
    end

    return Dir.glob("#{env[:TMP]}/.__packo_build/#{package.name}-#{package.version}*.pko").first
  end

  def _has (package, env)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.include?(
        %{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip
      )
    }
  end

  def _filter (package, env)
    env[:FLAVOR] = env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.join(' ')

    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        /Features:\s+(.+)$/
      )
    }

    if !matches
      env[:FEATURES] = ''
    else
      features       = matches[1].split(/\s+/)
      env[:FEATURES] = env[:FEATURES].split(/\s+/).delete_if {|f|
        !features.member?(f)
      }.join(' ')
    end
  end

  def _digest (package, env)
    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        %r{#{Regexp.escape(%{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip)}.*?\(SHA1 (.*?)\)}
      )
    }

    return matches[1] if matches
  end
end

Application.dispatch
