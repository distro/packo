#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'
require 'open-uri'

require 'packo'
require 'packo_binary'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  class_opt 'database', 'The path to the database', :default => Packo::Environment[:CACHE]

  desc 'Outputs version'
  def version
    puts "packø #{Packo::Version}"
  end

  desc 'Installs packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/'
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def install (*name)
    _database

    FileUtils.mkpath params['destination'] rescue nil
    FileUtils.mkpath Packo::Environment[:SELECTOR_MODULES] rescue nil

    name.each {|name|
      packages = nil

      if Packo::Environment.new[:FLAVOR].include?('binary')
        packages = _search(name, :binary, params['repository'])

        if packages.empty?
          warn "#{name} could not be found in the binary repositories, looking in source repositories"
          packages = nil
        end
      end

      packages = _search(name, :source, params['repository']) if !packages

      names = packages.group_by {|package|
        "#{package.categories.join('/')}/#{package.name}"
      }.map {|(name, package)| name}.uniq

      if names.length > 1
        fatal "More than one package matches: #{name}"
        names.each {|name|
          puts "    #{name}"
        }
        
        exit 10
      end

      package = packages.sort {|a, b|
        a.version <=> b.version
      }.last

      if !package
        fatal "#{name} not found"
        exit 11
      end

      environment = Packo::Environment.new(package)

      case package.repository.type
        when :binary
          name = "#{package.categories.join('/')}/#{package.name}-#{package.version}"

          flavors = ''
          environment[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.each {|f|
            flavors << ".#{f}"
          }
          flavors[0, 1] = ''

          features = ''
          environment[:FEATURES].split(/\s+/).each {|f|
            features << "-#{f}"
          }
          features[0, 1] = ''

          name << "+#{flavors}" if !flavors.empty?
          name << "-#{features}" if !features.empty?

          name << "%#{package.slot}"
          name << ".pko"

          if !File.exist?("#{Packo::Environment[:TMP]}/#{name}")
            file = File.new("#{Packo::Environment[:TMP]}/#{name}", 'w')
            file.write(open("#{_uri(package.repository)}/#{name}").read)
            file.close
          end

          name = "#{Packo::Environment[:TMP]}/#{name}"

        when :source
          name = _build package
      end

      ap name; exit

      path = "#{Packo::Environment[:TMP]}/#{name}.unpacked"

      case File.extname(name)
        when '.pko'
          Packo::Modules::Packaging::PKO.unpack(File.realpath(name), path)

          manifest = Packo::Package::Manifest.open("#{path}/manifest.xml")

          manifest.selectors.each {|selector|
            FileUtils.cp_r "#{path}/selectors/#{selector.path}", Packo::Environment[:SELECTOR_MODULES], :preserve => true, :remove_destination => true
            Packo.sh 'packo-select', 'add', selector.name, selector.description, "#{Packo::Environment[:SELECTOR_MODULES]}/#{selector.path}", :silent => true
          }

          FileUtils.cp_r Dir.glob("#{path}/dist/*"), params['destination'], :preserve => true, :remove_destination => true

        else
          fatal 'Unknown package type'
          exit 10
      end
    }
  end

  desc 'Uninstalls packages'
  def uninstall (*name)
    _database

  end

  def show
    @db.execute('SELECT * FROM present').each {|package|
      
    }
  end

  desc 'Manages packø building system'
  def build (*argument)
    cmd = "sandbox packo-build"

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages various configurations'
  def select (*argument)
    cmd = 'packo-select'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø repositories'
  def repository (*argument)
    cmd = 'sandbox packo-repository'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø environment'
  def env (*argument)
    cmd = 'packo-env'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  def params= (params)
    @params = params

    if File.directory? params['database']
      fatal "#{params['database']} is a directory"
      exit 42
    end

    begin
      FileUtils.mkpath(File.dirname(params['database']))
    rescue Exception => e
      fatal "Could not create #{File.dirname(params['database'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['database'])
    @db.results_as_hash = true
  end

  private

  def _database
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS installed (
        id INTEGER PRIMARY KEY AUTOINCREMENT,

        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT DEFAULT NULL,

        flavors  TEXT,
        features TEXT,

        manual INTEGER DEFAULT 0,

        UNIQUE (categories, name, slot)
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS dependencies (
        package           INTEGER,
        needed_by_package INTEGER
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS files (
        package INTEGER,

        path TEXT
      )
    })
  end

  def _search (package, type, repository=nil)
    `packo-repository #{"--repository='#{repository}'" if repository} --type='#{type}' --full=true search '#{package}'`.lines.map {|line|
      matches = line.match(%r{^(.*?)\s*\((.*?)/(.*?) \| (.*?) \| (.*?)\)$})

      next if !matches

      pkg = Packo::Package.parse(matches[1])

      PackoBinary::Package.new(pkg.categories.join('/'), pkg.name, pkg.version, pkg.slot, OpenStruct.new(
				:type => matches[2].to_sym,
        :name => matches[3],
        :uri  => matches[4],
        :path => matches[5]
      ))
    }.compact
  end

  def _uri (repository)
    `packo-repository uri '#{repository.type}/#{repository.name}'`.strip
  end

  def _build (package)
    FileUtils.rm_rf "#{Packo::Environment[:TMP]}/.__packo_build", :secure => true rescue nil
    FileUtils.mkpath "#{Packo::Environment[:TMP]}/.__packo_build" rescue nil

    if system("sandbox packo-build --output='#{Packo::Environment[:TMP]}/.__packo_build' --repository='#{package.repository.type}/#{package.repository.name}' package #{package.to_s}") == 0
      File.realpath(Dir.glob("#{Packo::Environment[:TMP]}/.__packo_build/*.pko").first)
    end
  end
end

Application.dispatch
