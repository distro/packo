#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'packo'
require 'optitron'
require 'sqlite3'
require 'rexml/document'

require 'packo_binary'

class Application < Optitron::CLI
  include Helpers

  class_opt 'cache', 'The path to the cache file', :default => Packo.env('CACHE') || '/var/lib/packo/cache'

  desc 'Builds packages'
  opt 'tmp', 'The path to the temporary directory', :default => Packo.env('TMP') || '/tmp'
  opt 'output', 'The directory where to save packages', :default => Packo.env('TMP') || '/tmp'
  def build (*names)
    Packo.env('TMP', params['tmp'])

    names.map {|package|
      tmp = []

      Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << Package.new(pkg['name'], pkg['version'], pkg['categories'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        puts 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      path = "#{package.tree.path}/#{package.categories.join('/')}/#{package.name}"

      begin
        load "#{path}/#{package.name}.rbuild"
        load "#{path}/#{package.name}-#{package.version}.rbuild"
      rescue LoadError
        warn 'One of the rbuilds could not be found'
      end

      if !Packo::Packages[(package.categories + [package.name]).join('/')]
        warn 'The package does not have a parent'
      end

      package = Package.envify(Packo::Packages[package.to_s]) rescue nil

      if !package
        fatal 'Package could not be instantiated'
        exit 23
      end

      info "Building #{package}"

      output = File.realpath(params['output'])

      package.on :packed do |path|
        FileUtils.cp path, output, :verbose => true, :preserve => true
      end

      if (File.read("#{package.directory}/.build") rescue nil) != package.to_s
        info "Cleaning #{package} because flavors/features changed."

        clean(package.to_s)

        file = File.new("#{package.directory}/.build", 'w')
        file.write package.to_s
        file.close
      end

      begin
        package.build {|stage|
          info "Executing #{stage.name}"
        }
      rescue Exception => e
        Packo.debug e, :force => true
      end
    }
  end

  desc 'Clean a package'
  opt 'tmp', 'The path to the temporary directory', :default => Packo.env('TMP') || '/tmp'
  def clean (*names)
    names.map {|package|
      tmp = []

      Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << Package.new(pkg['name'], pkg['version'], pkg['categories'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        puts 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      begin
        path = "#{params['tmp']}/#{package.to_s(true)}/#{package.version}"

        FileUtils.rm_r "#{path}/work"; FileUtils.mkpath "#{path}/work"
        FileUtils.rm_r "#{path}/dist"; FileUtils.mkpath "#{path}/dist"
      rescue Exception => e
      end
    }
  end

  desc 'Installs packages'
  def install (*names)

  end

  desc 'Searches packages with the given expression'
  opt 'exact', 'Search for the exact name', :type => :boolean, :default => false
  def search (expression='')
    Tree.all(@db).each {|tree|
      tree.search(expression, params['exact']).each {|package|
        puts Package.new(package['name'], package['version'], package['categories']).to_s
      }
    }
  end

  desc 'Creates the cache file'
  def cache (*trees)
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS trees (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
  
        name TEXT,
        path TEXT,
  
        UNIQUE (name)
      )
    })
  
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS packages (
        name       TEXT,
        version    TEXT,
        categories TEXT,
  
        tree INTEGER,
  
        UNIQUE (name, version, categories)
      )
    })

    trees.each {|tree|
      Tree.create(@db, REXML::Document.new(File.new("#{tree}/tree.xml")), File.realpath(tree)).update
    }
  
    @db.commit rescue nil
  end

  desc 'Output version'
  def version
    puts "pack√∏ #{Packo::Version}"
  end

  def params= (params)
    @params = params

    if File.directory? params['cache']
      puts "#{colorize('*', :RED)} #{params['cache']} is a directory"
    end

    begin
      FileUtils.mkpath(File.dirname(params['cache']))
    rescue
      puts "#{colorize('*', :RED)} Could not create #{File.dirname(params['cache'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['cache'])
    @db.results_as_hash = true
  end
end

Application.dispatch
