#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'open-uri'
require 'digest/sha1'
require 'find'

require 'packo'
require 'packo/binary'
require 'packo/models'
require 'packo/rbuild/modules/packaging'

class Application < Optitron::CLI
  include Packo::Binary::Helpers
  include Packo::Models

  desc 'Outputs version'
  def version
    puts "packø #{Packo::VERSION}"
  end

  desc 'Installs packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/', :short_name => 'd'
  opt 'inherit', 'Apply the passed flags to the eventual dependencies', :type => :boolean, :default => false
  opt 'force', 'Force installation when something minor goes wrong', :type => :boolean, :default => false
  opt 'nodeps', 'Ignore blockers and dependencies', :type => :boolean, :default => false
  opt 'repository', 'Set a specific repository', :type => :string, :short_name => 'r'
  def install (*name)
    outside = params['destination'] != '/'

    FileUtils.mkpath params['destination'] rescue nil
    FileUtils.mkpath Packo::Environment[:SELECTOR_MODULES] rescue nil

    binary = false

    if name.last === true
      manual = name.shift ? 0 : 1
    else
      manual = 1
    end

    name.each {|name|
      if File.extname(name).empty?
        packages = nil
  
        if Packo::Environment.new[:FLAVOR].include?('binary')
          packages = _search(name, :binary, params['repository'])
  
          if packages.empty?
            warn "#{name} could not be found in the binary repositories, looking in source repositories"
            packages = nil
          else
            binary = true
          end
        end
  
        begin
          if !packages
            packages = _search(name, :source, params['repository'])
  
            binary = false
          end
  
          names = packages.group_by {|package|
            "#{package.tags}/#{package.name}"
          }.map {|(name, package)| name}.uniq
  
          if names.length > 1
            fatal "More than one package matches: #{name}"
            names.each {|name|
              puts "    #{name}"
            }
          
            exit 10
          end
  
          package = packages.sort {|a, b|
            a.version <=> b.version
          }.last
  
          if !package
            fatal "#{name} not found"
            exit! 11
          end
  
          env = Packo::Environment.new(package)
  
          _filter(package, env)
  
          if package.repository.type == :binary && !_has(package, env)
            warn 'The binary package is not available with the features you asked for, trying to build from source'
            packages = nil
            raise ArgumentError
          end
        rescue ArgumentError
          retry
        end
  
        case package.repository.type
          when :binary
            name = "#{package.tags.to_s(true)}/#{package.name}-#{package.version}"
  
            flavors = ''
            env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.each {|f|
              flavors << ".#{f}"
            }
            flavors[0, 1] = ''
  
            features = ''
            env[:FEATURES].split(/\s+/).each {|f|
              features << "-#{f}"
            }
            features[0, 1] = ''
  
            name << "%#{package.slot}"
            name << "+#{flavors}"
            name << "-#{features}"
            name << ".pko"
  
            FileUtils.mkpath(File.dirname("#{env[:TMP]}/#{name}")) rescue nil
  
            begin
              Packo.sh 'wget', '-c', '-O', "#{env[:TMP]}/#{name}", "#{_uri(package.repository)}/#{name}"
            rescue RuntimeError
              FileUtils.rm "#{env[:TMP]}/#{name}"
              fatal "Failed to download #{name}"
              exit! 12
            end
  
            name = "#{env[:TMP]}/#{name}"
  
            if (digest = _digest(package, env)) && (result = Digest::SHA1.hexdigest(File.read(name))) != digest
              fatal "Digest mismatch (got #{result} expected #{digest}), install this package from source, the mirror could be compromised"
              exit 99
            end
  
            path = "#{env[:TMP]}/.__packo_unpacked/#{name[env[:TMP].length, name.length]}"
  
          when :source
            name = _build(package, env)
            path = "#{env[:TMP]}/.__packo_unpacked/#{package.tags.to_s(true)}/#{name[env[:TMP].length + '.__packo_build/'.length, name.length]}"
        end
      else
        env  = Packo::Environment.new
        path = "#{env[:TMP]}/.__packo_unpacked/#{File.basename(name)}"
      end

      FileUtils.rm_rf path, :secure => true

      case File.extname(name)
        when '.pko'
          Packo::RBuild::Modules::Packaging::PKO.unpack(File.realpath(name), path)

          manifest = Packo::Package::Manifest.open("#{path}/manifest.xml")

        else
          fatal 'Unknown package type'
          exit! 14
      end

      if !params['inherit']
        Packo::Environment[:FLAVOR] = Packo::Environment[:FEATURES] = ''
      end

      if !params['nodeps']
        manifest.blockers {|blocker|
          if (blocker.runtime? || !binary) && _installed?(blocker)
            fatal "#{blocker} can't be installed with #{package}"
            exit! 15
          end
        }

        manifest.dependencies.each {|dependency|
          install(dependency.to_s) if dependency.runtime? || !binary
        }
      end

      manifest.selectors.each {|selector|
        FileUtils.cp_r "#{path}/selectors/#{selector.path}", env[:SELECTOR_MODULES], :preserve => true, :remove_destination => true
        Packo.sh 'packo-select', 'add', selector.name, selector.description, "#{env[:SELECTOR_MODULES]}/#{selector.path}", :silent => true
      }

      pkg = InstalledPackage.new(:repo => params['repository'],
        :tags     => manifest.package.tags.hash,
        :name     => manifest.package.name,
        :version  => manifest.package.version,
        :slot     => manifest.package.slot,
        :revision => manifest.package.revision,

        :flavors  => manifest.package.flavors,
        :features => manifest.package.features,
        
        :manual  => manual,
        :runtime => true
      )

      length = "#{path}/dist".length

      begin
        Find.find("#{path}/dist") {|file|
          type = nil
          path = "#{params['destination']}/#{file[length, file.length]}".gsub(%r{/*/}, '/')
          fake = path[params['destination'].length, path.length]
          meta = nil

          if !outside && pkg = _exists?(fake) && !params['force']
            fatal "#{path} belongs to #{pkg}, use --force to force overwrite"
            raise RuntimeError.new 'File collision'
          end
  
          if File.directory? file
            type = 'dir'
            FileUtils.mkpath path
          elsif File.symlink? file
            type = 'sym'
            meta = File.readlink file

            FileUtils.rm_f path
            File.symlink meta, path
          elsif File.file? file
            type = 'obj'
            meta = Digest::SHA1.hexdigest(File.read(file))
            FileUtils.cp file, path, :preserve => true
          else
            next
          end

          case type
            when 'dir'; puts colorize("--- #{path}", :DEFAULT, :DEFAULT, :BOLD)
            when 'sym'; puts colorize(">>> #{path} -> #{meta}", :BLUE, :DEFAULT, :BOLD)
            when 'obj'; puts ">>> #{path}"
          end
  
          pkg.contents.new(
            :type => type.to_sym,
            :path => fake,
            :meta => meta
          )
        }
      rescue Exception => e
        fatal 'Something went deeply wrong when installing package contents'
        Packo.debug e, :force => true
        exit! 17
      end

      if !(outside && !params['force'])
        pkg.save
      end
    }
  end

  desc 'Uninstalls packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/', :short_name => 'd'
  def uninstall (*name)
    name.each {|name|
      InstalledPackage.search(name).each {|installed|
        installed.contents.each {|content|
          path = "#{params['destination']}/#{content['path']}".gsub(%r{/*/}, '/')

          case content.type
            when :obj
              puts "<<< #{path}"
              FileUtils.rm_f(path)

            when :sym
              puts colorize("<<< #{path} -> #{meta}", :BLUE, :DEFAULT, :BOLD)
              FileUtils.rm_f(path)

            when :dir
              puts colorize("--- #{path}", :DEFAULT, :DEFAULT, :BOLD)
              Dir.delete(path) rescue nil
          end
        }

        installed.destroy
      }
    }
  end

  def show
    InstalledPackage.all.each {|package|
      # TODO: real tagging
      print "#{package.tags}/#{colorize(package.name, :DEFAULT, :DEFAULT, :BOLD)}"
      print "-#{colorize(package.version, :RED)}"
      print "%#{colorize(package.slot, :BLUE, :DEFAULT, :BOLD)}" if package.slot

      print " [#{package.features}]" if package.features
      print " {#{package.flavors}}" if package.flavors
    }
  end

  desc 'Manages various informations about package contents'
  def files (*argument)
    cmd = 'packo-files'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø building system'
  def build (*argument)
    cmd = 'sandbox packo-build'

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages various configurations'
  def select (*argument)
    cmd = 'packo-select'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  desc 'Manages packø repositories'
  def repository (*argument)
    cmd = 'sandbox packo-repository'

    argument.compact.each {|arg|
      cmd << %Q{ '"#{arg}"'}
    }

    exit! system(cmd)
  end

  desc 'Manages packø environment'
  def env (*argument)
    cmd = 'packo-env'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    exit! system(cmd)
  end

  private

  def _installed? (package)
    InstalledPackage.first(
      :tags     => package.tags.hashed,
      :name     => package.name,
      :version  => package.version,
      :slot     => package.slot
    )
  end

  def _search (package, type, repository=nil)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository #{"--repository='#{repository}'" if repository} --type='#{type}' --full=true search '#{package}'`.lines.map {|line|
        matches = line.match(%r{^(.*?)\s*\((.*?)/(.*?) \| (.*?) \| (.*?)\)$})

        next if !matches

        pkg = Packo::Package.parse(matches[1])

        Packo::Package.new(
          :tags    => pkg.tags,
          :name    => pkg.name,
          :version => pkg.version,
          :slot    => pkg.slot,

          :repository =>OpenStruct.new(
            :type => matches[2].to_sym,
            :name => matches[3],
            :uri  => matches[4],
            :path => matches[5]
          )
        )
      }.compact
    }
  end

  def _uri (repository)
    `packo-repository uri '#{repository.type}/#{repository.name}'`.strip
  end

  def _build (package, env)
    FileUtils.rm_rf "#{env[:TMP]}/.__packo_build", :secure => true rescue nil
    FileUtils.mkpath "#{env[:TMP]}/.__packo_build" rescue nil

    if !system("sandbox packo-build --output='#{env[:TMP]}/.__packo_build' --repository='#{package.repository.type}/#{package.repository.name}' package #{package.to_s}")
      raise RuntimeError.new 'Build failed'
    end

    return Dir.glob("#{env[:TMP]}/.__packo_build/#{package.name}-#{package.version}*.pko").first
  end

  def _has (package, env)
    Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.include?(
        %{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip
      )
    }
  end

  def _filter (package, env)
    env[:FLAVOR] = env[:FLAVOR].split(/\s+/).reject {|f| f == 'binary'}.join(' ')

    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        /Features:\s+(.+)$/
      )
    }

    if !matches
      env[:FEATURES] = ''
    else
      features       = matches[1].split(/\s+/)
      env[:FEATURES] = env[:FEATURES].split(/\s+/).delete_if {|f|
        !features.member?(f)
      }.join(' ')
    end
  end

  def _digest (package, env)
    matches = Packo::Environment.sandbox(:NO_COLORS => 1) {
      `packo-repository info --repository='binary/#{package.repository.name}' '#{package.to_s}'`.match(
        %r{#{Regexp.escape(%{With #{
            env[:FEATURES].empty? ? 'nothing' : env[:FEATURES].split(/\s+/).join(' ')
          }#{" in #{
            env[:FLAVOR].split(/\s+/).join(' ')
          } flavor" if !env[:FLAVOR].empty?}
        }.strip)}.*?\(SHA1 (.*?)\)}
      )
    }

    return matches[1] if matches
  end

  def _exists? (path)
    InstalledPackage::Content.first(:path.eql => path, :type.not => :dir).package rescue false
  end
end

Application.dispatch
