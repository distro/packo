#! /usr/bin/env ruby
# encoding: utf-8
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'optitron'
require 'sqlite3'

require 'packo'
require 'packo_binary/helpers'

class Application < Optitron::CLI
  include PackoBinary::Helpers

  class_opt 'database', 'The path to the database', :default => Packo::Environment[:CACHE]

  desc 'Outputs version'
  def version
    puts "packø #{Packo::Version}"
  end

  desc 'Installs packages'
  opt 'destination', 'Set the destination where to install the package', :default => '/'
  def install (*name)
    _database

    FileUtils.mkpath params['destination'] rescue nil
    FileUtils.mkpath Packo::Environment[:SELECTOR_MODULES] rescue nil

    name.each {|name|
      info "Installing #{name}"

      path = "#{Packo::Environment[:TMP]}/#{name}"

      case File.extname(name)
        when '.pko'
          Packo::Modules::Packaging::PKO.unpack(File.realpath(name), path)

          manifest = Packo::Package::Manifest.open("#{path}/manifest.xml")

          manifest.selectors.each {|selector|
            FileUtils.cp_r "#{path}/selectors/#{selector.path}", Packo::Environment[:SELECTOR_MODULES], :preserve => true, :remove_destination => true
            Packo.sh 'packo-select', 'add', selector.name, selector.description, "#{Packo::Environment[:SELECTOR_MODULES]}/#{selector.path}", :silent => true
          }

          FileUtils.cp_r Dir.glob("#{path}/dist/*"), params['destination'], :preserve => true, :remove_destination => true

        else
          fatal 'Unknown package type'
          exit 10
      end
    }
  end

  desc 'Uninstalls packages'
  def uninstall (*name)
    _database

  end

  def show
    @db.execute('SELECT * FROM present').each {|package|
      
    }
  end

  desc 'Manages packø building system'
  def build (*argument)
    cmd = "sandbox packo-build"

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    system(cmd)
  end

  desc 'Manages various configurations'
  def select (*argument)
    cmd = 'packo-select'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    system(cmd)
  end

  desc 'Manages packø repositories'
  def repository (*argument)
    cmd = 'sandbox packo-repository'

    cmd << " --database='#{params['database']}'" if params['database'] != Packo::Environment[:CACHE]

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    system(cmd)
  end

  desc 'Manages packø environment'
  def env (*argument)
    cmd = 'packo-env'

    argument.compact.each {|arg|
      cmd << %Q{ "#{arg}"}
    }

    system(cmd)
  end

  def params= (params)
    @params = params

    if File.directory? params['database']
      fatal "#{params['database']} is a directory"
      exit 42
    end

    begin
      FileUtils.mkpath(File.dirname(params['database']))
    rescue Exception => e
      fatal "Could not create #{File.dirname(params['database'])}"
      exit 42
    end

    @db = SQLite3::Database.new(params['database'])
    @db.results_as_hash = true
  end

  private

  def _database
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS installed (
        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT DEFAULT NULL,

        manual INTEGER DEFAULT 0,

        UNIQUE (categories, name, slot)
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS dependencies (
        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT DEFAULT NULL,
       
        needed_by_categories TEXT,
        needed_by_name       TEXT,
        needed_by_version    TEXT,
        needed_by_slot       TEXT DEFAULT NULL,
      )
    })

    @db.execute(%{
      CREATE TABLE IF NOT EXISTS files (
        categories TEXT,
        name       TEXT,
        version    TEXT,
        slot       TEXT,

        path TEXT
      )
    })
  end
end

Application.dispatch
