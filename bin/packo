#! /usr/bin/env ruby
#--
# Copyleft meh. [http://meh.doesntexist.org | meh@paranoici.org]
#
# This file is part of packo.
#
# packo is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as published
# by the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# packo is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
#
# You should have received a copy of the GNU Affero General Public License
# along with packo. If not, see <http://www.gnu.org/licenses/>.
#++

require 'packo'
require 'optimus'
require 'sqlite3'
require 'rexml/document'

class Application
  attr_reader :command, :options

  def initialize
    @command = ARGV.shift
    
    case command
      when 'build'
        @options = Optimus.new {|o|
          o.set(
            :long => 'tmp',
            :short => 't',
    
            :default => '/tmp'
          )

          o.set(
            :long  => 'cache',
            :short => 'c',

            :default => Packo.env('CACHE') || '/var/lib/packo/cache'
          )
        }
    
      when 'install'
        @options = Optimus.new {|o|
           o.set(
            :long  => 'cache',
            :short => 'c',

            :default => Packo.env('CACHE') || '/var/lib/packo/cache'
          )   
        }
    
      when 'cache'
        @options = Optimus.new {|o|
          o.set(
            :type => :array,
    
            :long  => 'trees',
            :short => 'T',
    
            :default => Packo.env('TREES') || '/usr/packo'
          )
    
          o.set(
            :long  => 'output',
            :short => 'o',
    
            :default => Packo.env('CACHE') || '/var/lib/packo/cache'
          )
        }

      when 'search'
        @options = Optimus.new {|o|
          o.set(
            :long  => 'cache',
            :short => 'c',

            :default => Packo.env('CACHE') || '/var/lib/packo/cache'
          )
        }

    end

    FileUtils.mkpath(File.dirname(@options.params[:cache] || @options.params[:output]))
    @db = SQLite3::Database.new(@options.params[:cache] || @options.params[:output])
    @db.results_as_hash = true
  end

  def run!
    method = self.method("cmd_#{@command}".to_sym)

    if !method
      self.help!
      exit 1
    end

    method.call
  end

  def help!

  end

  module Helpers
    def self.colorize (text, fg, bg=nil, attr=nil)
      colors = {
        :DEFAULT => 9,
        nil      => 9,
  
        :BLACK   => 0,
        :RED     => 1,
        :GREEN   => 2,
        :YELLOW  => 3,
        :BLUE    => 4,
        :MAGENTA => 5,
        :CYAN    => 6,
        :WHITE   => 7
      }
  
      attributes = {
        :DEFAULT => 0,
        nil      => 0,
  
        :BOLD      => 1,
        :UNDERLINE => 4,
        :BLINK     => 5,
        :REVERSE   => 7
      }

      "\e[#{attributes[attr]};3#{colors[fg]};4#{colors[bg]}m#{text}\e[0m"
    end
  end

  class Package
    def self.envify (package)
      Packo.env('FLAVOR', 'headers documentation') if !Packo.env('FLAVOR')
  
      package.flavors.binary!            if Packo.env('FLAVOR').include?('binary')
      package.flavors.not_headers!       if !Packo.env('FLAVOR').include?('headers')
      package.flavors.not_documentation! if !Packo.env('FLAVOR').include?('documentation')
      package.flavors.debug!             if Packo.env('FLAVOR').include?('debug')
      package.flavors.minimal!           if Packo.env('FLAVOR').include?('minimal')
      package.flavors.vanilla!           if Packo.env('FLAVOR').include?('vanilla')

      (Packo.env('FEATURES') || '').split(/\s+/).each {|feature|
        feature = Packo::Feature.parse(feature)

        package.features {
          self[feature.name].merge(feature) if self[feature.name]
        }
      }

      package
    end

    attr_reader :name, :version, :categories, :tree

    def initialize (name, version, categories, tree=nil)
      @name       = name
      @version    = version
      @categories = (categories || '').split('/')
      @tree       = tree
    end

    def == (package)
      self.name == package.name && self.categories == package.categories
    end

    def to_s
      "#{(@categories + [@name]).join('/')}#{"-#{@version}" if @version}"
    end
  end

  class Tree
    def self.all (db)
      db.execute('SELECT * FROM trees').map {|tree|
        Tree.new(db, tree['name'])
      }
    end

    def self.name (dom)
      dom.elements.each('/tree/name') {|e| e.name == 'name'}.first.text rescue nil
    end

    def self.create (db, dom, path)
      name = Tree.name(dom)

      db.execute('INSERT OR IGNORE INTO trees VALUES(NULL, ?, ?)', [name, path])

      Tree.new(db, name)
    end

    attr_reader :id, :path

    def initialize (db, name)
      @db   = db
      @name = name

      result = @db.execute('SELECT * FROM trees WHERE name = ?', name).first

      @id   = result['id']
      @path = result['path']
    end

    def update
      _populate([@path])

      @db.commit rescue nil    
    end

    def search (package, precise=false)
      package = Packo::Package.parse(package)

      if !precise
        @db.execute(%{
          SELECT *

          FROM packages

          WHERE
            tree = ?
            #{'AND name LIKE ?' if package.name}
            #{'AND version LIKE ?' if package.version}
            #{'AND categories LIKE ?' if !package.categories.empty?}
        }, [@id,
          (package.name ? "%#{package.name}%" : nil),
          (package.version ? "%#{package.version}%" : nil),
          (!package.categories.empty? ? "%#{package.categories.join('/')}%" : nil)
        ].compact)
      else
        @db.execute(%{
          SELECT *

          FROM packages

          WHERE
            tree = ?
            #{'AND name = ?' if package.name}
            #{'AND version = ?' if package.version}
            #{'AND categories = ?' if !package.categories.empty?}
        }, [@id, package.name, package.version, package.categories.join('/')].compact)
      end
    end

    private

    def _populate (what)
      what.select {|what| File.directory? what}.each {|what|
        if File.file? "#{what}/#{File.basename(what)}.rbuild"
          Dir.glob("#{what}/#{File.basename(what)}-*.{rbuild,xml}").each {|version|
            version = version.match(/-(\d.*?)\.(rbuild|xml)$/)[1]

            @db.execute('INSERT OR IGNORE INTO packages VALUES(?, ?, ?, ?)', [
              File.basename(what), version, File.dirname(what.sub(%r{#{Regexp.escape(@path)}/}, '')), @id
            ])
          }
        else
          _populate(Dir.entries(what).map {|e| if e != '.' && e != '..' then "#{what}/#{e}" end}.compact)
        end
      }
    end
  end

  private

  def cmd_build
    @options.arguments.map {|package|
      tmp = []

      Tree.all(@db).each {|tree|
        tree.search(package, true).each {|pkg|
          tmp << Package.new(pkg['name'], pkg['version'], pkg['categories'], tree)
        }
      }

      if (multiple = tmp.uniq).length > 1
        puts 'Multiple packages with the same name, be more precise.'
        exit 2
      end

      tmp.last
    }.each {|package|
      path = "#{package.tree.path}/#{package.categories.join('/')}/#{package.name}"

      load "#{path}/#{package.name}.rbuild"
      load "#{path}/#{package.name}-#{package.version}.rbuild"

      package = Package.envify(Packo::Packages[package.to_s])

      puts "#{Helpers.colorize('*', :GREEN, :DEFAULT, :BOLD)} Building #{package}"

      package.build {|stage|
        puts "#{Helpers.colorize('*', :GREEN, :DEFAULT, :BOLD)} Executing #{stage.name}."
      }
    }
  end

  def cmd_install
  end

  def cmd_search
    Tree.all(@db).each {|tree|
      tree.search(@options.arguments.first || '').each {|package|
        puts Package.new(package['name'], package['version'], package['categories']).to_s
      }
    }
  end

  def cmd_cache
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS trees (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
  
        name TEXT,
        path TEXT,
  
        UNIQUE (name)
      )
    })
  
    @db.execute(%{
      CREATE TABLE IF NOT EXISTS packages (
        name       TEXT,
        version    TEXT,
        categories TEXT,
  
        tree INTEGER,
  
        UNIQUE (name, version, categories)
      )
    })

    @options.params[:trees].each {|tree|
      Tree.create(@db, REXML::Document.new(File.new("#{tree}/tree.xml")), File.realpath(tree)).update
    }
  
    @db.commit rescue nil
  end
end

app = Application.new
app.run!
